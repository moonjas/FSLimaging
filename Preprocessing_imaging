{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# these codes purpose for studying automatic-pipeline \n",
    "# The code below has been changed to automate on a per-participant basis\n",
    "\n",
    "# original codes\n",
    "# https://github.com/sathayas/JupyterfMRIFall2019/blob/master/README.md\n",
    "\n",
    "# it only works in docker environment, types it in terminal if you install docker and download the data fully.\n",
    "# docker pull sathayas/python-fsl-bundle \n",
    "# docker run -it --rm -p 8888:8888 -v [Path to Data folder]:/tmp/Data:z sathayas/python-fsl-bundle\n",
    "# then type jnb (jupyter notebook). You should see tmp/Data on home page of the jupyter notebook. \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline #magical codes\n",
    "\n",
    "import os\n",
    "import numpy as np\n",
    "import nibabel as nib\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.image as mpimg\n",
    "import nipype.interfaces.fsl as fsl # importing FSL interface functions\n",
    "from nipype import Node, Workflow  # components to construct workflow\n",
    "from nipype.interfaces.io import DataSink  # datasink\n",
    "from bids.layout import BIDSLayout  # BIDSLayout object to specify file(s)\n",
    "from nilearn import image\n",
    "from nilearn.plotting import plot_anat, view_img\n",
    "\n",
    "\n",
    "# Directory where your data set resides.\n",
    "dataDir = '/tmp/Data/ds114'\n",
    "\n",
    "\n",
    "# Creating the layout object for this BIDS data set\n",
    "layout = BIDSLayout(dataDir)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "i = layout.get_subjects()\n",
    "for subjectNum in i:\n",
    "    # an fMRI image from one of the subjects (finger foot lips, test)\n",
    "    imagefMRI = layout.get(subject=subjectNum,\n",
    "                           session='test',\n",
    "                           suffix='bold',\n",
    "                           task='fingerfootlips',\n",
    "                           extension='nii.gz',\n",
    "                           return_type='file')[0]\n",
    "\n",
    "    # an T1 image for the same subject (test)\n",
    "    imageT1 = layout.get(subject=subjectNum,\n",
    "                         session='test',\n",
    "                         suffix='T1w',\n",
    "                         extension='nii.gz',\n",
    "                         return_type='file')[0]\n",
    "\n",
    "\n",
    "    # template image (from FSL)\n",
    "    fMNI = '/usr/share/fsl/data/standard/MNI152_T1_2mm_brain.nii.gz'\n",
    "\n",
    "    # brain mask in MNI space (from FSL)\n",
    "    fmask = '/usr/share/fsl/data/standard/MNI152_T1_2mm_brain_mask_dil.nii.gz'\n",
    "\n",
    "\n",
    "\n",
    "    # Output directory\n",
    "    outDir = os.path.join(dataDir, 'WorkflowOutput')\n",
    "\n",
    "    #\n",
    "    #    T1 Normalization workflow\n",
    "    #\n",
    "    # Skullstrip process node\n",
    "    fslBET = Node(fsl.BET(in_file=imageT1),\n",
    "                  name=\"fslBET\")\n",
    "\n",
    "\n",
    "    # Linear normalization node\n",
    "    fslFLIRT = Node(fsl.FLIRT(reference=fMNI,\n",
    "                              cost_func='normmi'),\n",
    "                    name=\"fslFLIRT\")\n",
    "\n",
    "    # Non-linear normalization node\n",
    "    fslFNIRT = Node(fsl.FNIRT(ref_file=fMNI,\n",
    "                              fieldcoeff_file=True),\n",
    "                    name='fslFNIRT')\n",
    "\n",
    "    # Creating a workflow object\n",
    "    normT1wf = Workflow(name=\"normT1wf\", base_dir=outDir)\n",
    "\n",
    "    # connecting nodes as a T1 normalization workflow\n",
    "    normT1wf.connect(fslBET, \"out_file\", fslFLIRT, \"in_file\")\n",
    "    normT1wf.connect(fslBET, 'out_file', fslFNIRT, 'in_file')\n",
    "    normT1wf.connect(fslFLIRT, 'out_matrix_file', fslFNIRT, 'affine_file')\n",
    "\n",
    "    #\n",
    "    #   fMRI pre-processing\n",
    "    #\n",
    "    # skip dummy scans\n",
    "    extract = Node(fsl.ExtractROI(in_file=imagefMRI,  # input image\n",
    "                                  t_min=4,            # first 4 volumes are deleted\n",
    "                                  t_size=-1),\n",
    "                   name=\"extract\")\n",
    "\n",
    "    # creating motion correction node\n",
    "    mcflirt = Node(fsl.MCFLIRT(save_rms=True,   # saving displacement parameters\n",
    "                               save_plots=True, #\n",
    "                               mean_vol=True),  # saving mean image\n",
    "                   name=\"mcflirt\")\n",
    "\n",
    "    # creating co-registration node (estimating the coregistration parameters)\n",
    "    coreg = Node(fsl.FLIRT(dof=6,       # specifying rigid-body (6-parameters)\n",
    "                           cost='normmi'), # normizied mutual info\n",
    "                 name=\"coreg\")\n",
    "\n",
    "    # applying the coregistration and normalization parameters to fMRI data\n",
    "    applywarp = Node(fsl.ApplyWarp(ref_file=fMNI),\n",
    "                     name=\"applywarp\")\n",
    "\n",
    "    # smoothing with SUSAN\n",
    "    susan = Node(fsl.SUSAN(brightness_threshold = 2000.0,  # brightness threshold\n",
    "                           fwhm=6.0),    # smoothing filter width (6mm, isotropic)\n",
    "                 name='susan')\n",
    "\n",
    "    # masking the fMRI with a brain mask\n",
    "    applymask = Node(fsl.ApplyMask(mask_file=fmask),\n",
    "                     name='applymask')\n",
    "\n",
    "\n",
    "    # creating datasink to collect outputs\n",
    "    datasink = Node(DataSink(base_directory=outDir),\n",
    "                    name='datasink')\n",
    "\n",
    "\n",
    "    # creating a workflow\n",
    "    preprocfMRI = Workflow(name=\"PreprocfMRI\", base_dir=outDir)\n",
    "\n",
    "    # connecting the nodes to the main workflow\n",
    "    preprocfMRI.connect(extract, 'roi_file', mcflirt, 'in_file')\n",
    "    preprocfMRI.connect(mcflirt, 'mean_img', coreg, 'in_file')\n",
    "    preprocfMRI.connect(normT1wf, 'fslBET.out_file', coreg, 'reference')\n",
    "    preprocfMRI.connect(mcflirt, 'out_file', applywarp, 'in_file')\n",
    "    preprocfMRI.connect(coreg, 'out_matrix_file', applywarp, 'premat')\n",
    "    preprocfMRI.connect(normT1wf, 'fslFNIRT.fieldcoeff_file', applywarp, 'field_file')\n",
    "    preprocfMRI.connect(applywarp, 'out_file', susan, 'in_file')\n",
    "    preprocfMRI.connect(susan, 'smoothed_file', applymask, 'in_file')\n",
    "\n",
    "    # connection to data sink\n",
    "    preprocfMRI.connect(mcflirt,'par_file', datasink, 'par_file')\n",
    "    preprocfMRI.connect(mcflirt,'rms_files', datasink, 'rms_file')\n",
    "    preprocfMRI.connect(normT1wf, 'fslFNIRT.warped_file', datasink, 'NormT1')\n",
    "    preprocfMRI.connect(applywarp, 'out_file', datasink, 'NormfMRI')\n",
    "    preprocfMRI.connect(applymask, 'out_file', datasink, 'MaskSmoNormfMRI')\n",
    "\n",
    "\n",
    "    # running the workflow\n",
    "    preprocfMRI.run()\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": 3
  },
  "orig_nbformat": 2
 },
 "nbformat": 4,
 "nbformat_minor": 2
}